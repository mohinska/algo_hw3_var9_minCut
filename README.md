# Домашня робота #3
**Автор:** Марина Огінська  
**Варіант:** 9 — Мінімальний s-t переріз

## Мета
Реалізувати алгоритм знаходження мінімального s-t перерізу у орієнтованому графі з невід’ємними пропускними здатностями. Задача полягає у розбитті множини вершин на $S$ та $T$, де $s \in S$, $t \in T$, так щоб сума пропускних здатностей ребер з $S$ у $T$ була мінімальною.

## Вхідні та вихідні дані
**Вхідні дані:**
- Кількість вершин і ребер
- Для кожного ребра: початок, кінець, пропускна здатність
- Номери джерела $s$ та стоку $t$

**Вихідні дані:**
- Множини $S$ і $T$
- Значення мінімального перерізу

## Реалізація мінімального перерізу
- Використовується структура `dict` для зберігання графа: `self.graph = {u: {v: capacity, ...}, ...}`
- **Переваги над матрицею суміжності:**
  - Пам'ять: для розріджених графів матриця витрачає $O(V^2)$ пам’яті, більшість якої — нулі. Словник витрачає $O(V + E)$.
  - Швидкодія ітерації: BFS перебирає лише існуючих сусідів вершини. У матриці це $O(V)$, у списку суміжності — $O(\text{deg}(v))$.
  - Пошук ребра у `dict` займає $O(1)$ у середньому, що робить його швидким як матриця.

## Клас MinCutSolver
- Логіка інкапсульована у класі `MinCutSolver`.
- **Ініціалізація та додавання ребер:**
  - Метод `add_edge(u, v, capacity)` додає ребро.
  - Для алгоритму Едмондса-Карпа важливо мати зворотне ребро. Тому при додаванні ребра $u \to v$ перевіряється наявність $v \to u$; якщо його немає — ініціалізується нулем.

## Пошук у ширину (BFS)
- Метод `_bfs(residual_graph, s, t, parent)` знаходить найкоротший шлях у залишковому графі.
- Використовується `collections.deque` для черги (`popleft()` та `append()` виконуються за $O(1)$).
- Повертає `True`, якщо шлях знайдено, і заповнює словник `parent` для відновлення шляху.
- Переходити можна лише по ребрах з `capacity > 0`.

## Основний цикл (solve)
- Метод `solve(s, t)` працює у 2 цикла:
  1. **Max Flow:**
     - Створюється глибока копія графа (`r_graph`).
     - Поки `_bfs` знаходить шлях, обчислюється `path_flow` — мінімальна залишкова пропускна здатність на шляху.
     - Оновлюються ваги ребер у `r_graph`: прямі зменшуються, зворотні збільшуються.
  2. **Min Cut:**
     - Після завершення циклу BFS або DFS по `r_graph` від $s$.
     - Всі відвідані вершини формують $S$, невідвідані — $T$.
     - Ребра з $S$ у $T$ визначають мінімальний переріз.

## Порівняння з NetworkX
- Запуск власного алгоритму та `nx.maximum_flow_value` і `nx.minimum_cut`.
- Критерій успіху:
  - Обчислений максимальний потік співпадає.
  - Сумарна пропускна здатність перерізу співпадає.
  - (Опційно) Перевірка, що ребра перерізу дійсно розділяють граф на дві компоненти з $s$ і $t$.

## Аналіз продуктивності
- Використовувався модуль `timeit`.
- Типи графів: випадкові орієнтовані графи.
- Порівняння власна реалізація (Custom) vs `networkx.edmonds_karp` (NX).

**Результати вимірювань:**
```
--- Test ---
Custom Flow: 23, Custom Cut Capacity: 23
NetworkX Cut Capacity: 23
SUCCESS: Results match.

--- Benchmark ---
Size V=20, E=60 | Custom: 0.00008s | NX: 0.00038s
Size V=50, E=250 | Custom: 0.00030s | NX: 0.00110s
Size V=100, E=1000 | Custom: 0.00172s | NX: 0.00471s
Size V=200, E=4000 | Custom: 0.00709s | NX: 0.01842s
Size V=500, E=12500 | Custom: 0.07703s | NX: 0.06833s
```
**Аналіз результатів:**
- На малих графах власна реалізація швидша через накладні витрати бібліотеки.
- На великих графах NetworkX оптимізованіша, використовує C-бекенд та кешування.
- Час виконання зростає нелінійно, відповідає теоретичній складності $O(V E^2)$.

## Висновки
- Реалізовано алгоритм пошуку мінімального s-t перерізу.
- Коректність підтверджена тестами і порівнянням з NetworkX.
- Використано лише стандартні структури Python (`dict`, `list`, `deque`).
- Продуктивність хороша, особливо на малих і середніх графах, порівняно з NetworkX.
